function dataset_gene(I_IBG,β,v)  

#-----------------------------------Calculation of SCC constraints----------------------------------
    numnodes=30                         # number of nodes
    num_IBG=3                           # number of nodes where IBGs are located
    #            Bus Number	     x1	      x2
        SGpara=[
                   2	       0.0846	0.0812	
                   3	       0.0799	0.0774	
                   4	       0.0758	0.0735	
                   5	       0.0731	0.0713	
                   27	       0.0519	0.0457	
                   30	       0.0523	0.0469 ]  # buses where SGs are located

    Y_SGs = zeros(size(SGpara,1), size(SGpara,2)-1)    # define ADMITTANCE MATRIX of the SGs, buses:2,3,4,5,27,30
    I_SGs = zeros(size(SGpara,1), size(SGpara,2)-1)    # define I_SGs of the SGs, buses:2,3,4,5,27,30
    
    Yₗᵢₙₑ=admittance_matrix_calculation(numnodes)   # calculate the ADMITTANCE MATRIX of the network

    for k in 1:size(SGpara,1)                      # calculate the ADMITTANCE MATRIX of the SGs
        for j in 2:size(SGpara,2)
            Y_SGs[k, j-1] = 1/SGpara[k, j]/10        
        end           
    end 
    
    E_sg=v                   # nominal voltage of the SGs
    E_sg=β*E_sg
    I_SGs=Y_SGs.*E_sg        # calculate the I_SGs of the SGs, buses:2,3,4,5,27,30
    


#------------Evaluate the SCC at all buses in all Ω scenarios
    Ω=2^(length(SGpara[:,2:end])+num_IBG)-1                 # dimension of the data set, which is generated by evaluating SCC at different system conditions
                                                            # remove the first row of the matrix, as the first row is not realistic: all SGs and IBGs are off
    I_SCC_all_buses_scenarios=zeros(Ω,numnodes)             # SCC for all buses in all Ω scenarios
    ηm=zeros(Ω,binomial(length(SGpara[:,2:end]),2))         # product of each pair of SGs
    
    combinations = collect(product(0:1, repeat([0:1], length(SGpara[:,2:end])+num_IBG-1)...))    # generate all combinations of 21 binary variables: 18 SGs and 3 IBGs
    matrix = hcat([collect(combo) for combo in combinations]...)  # convert the combination to a matrix
    matrix = transpose(matrix)                                    # transpose the matrix
    matrix = matrix[2:end, :]                                     # remove the first row of the matrix, as the first row is not realistic: all SGs and IBGs are off

    for k in 1:Ω    # generate ηm by calculating the product of each pair of SGs in all Ω scenarios
        index = 1
        for i in 1:length(SGpara[:,2:end])-1
            for j in i+1:length(SGpara[:,2:end])
                ηm[k,index] = matrix[k,i] * matrix[k,j]
                index += 1
            end
        end
    end
    
    matrix_ω=hcat(matrix,ηm)
    
    status_SGs = zeros(1, length(SGpara[:,2:end]))     # define status of SGs
    status_IBG = zeros(1, num_IBG)             # define status of IBG
    Y_SGs_with_status = zeros(numnodes, numnodes)     # define the ADMITTANCE MATRIX for SGs status
    Y_total = zeros(numnodes, numnodes)        # define the total ADMITTANCE MATRIX
    Z = zeros(numnodes, numnodes)              # define the impedance matrix
    
    for j in 1:numnodes
        for k in 1:Ω
            status_SGs = matrix_ω[k, 1:length(SGpara[:,2:end])]                                     # status of SGs
            status_IBG = matrix_ω[k, length(SGpara[:,2:end])+1:length(SGpara[:,2:end]) + num_IBG]   # status of IBG
            Y_SGs_with_status .= 0                                                                  # reset Y_SGs_with_status matrix
        
            index = 1
            for i in 1:length(SGpara[:,2:end])
                Y_SGs_with_status[Int(SGpara[Int(ceil(i/2)), 1]), Int(SGpara[Int(ceil(i/2)), 1])] = Y_SGs_with_status[Int(SGpara[Int(ceil(i/2)), 1]), Int(SGpara[Int(ceil(i/2)), 1])]+Y_SGs[Int(ceil(i/2)),index] * status_SGs[i]  # status of SGs
                    index = index+1
                    if index > size(Y_SGs, 2)
                        index = 1
                    end
            end
        
            Y_total .= Yₗᵢₙₑ + Y_SGs_with_status      # calculate the total ADMITTANCE MATRIX
            Z .= inv(Y_total)                        # calculate the IMPEDANCE MATRIX
    
            I_SCC_all_buses_scenarios[k,j] = (
                Z[j,2]*(I_SGs[1, 1]*status_SGs[1]+ I_SGs[1, 2]*status_SGs[2])+
                Z[j,3]*(I_SGs[2, 1]*status_SGs[3]+ I_SGs[2, 2]*status_SGs[4])+
                Z[j,4]*(I_SGs[3, 1]*status_SGs[5]+ I_SGs[3, 2]*status_SGs[6])+
                Z[j,5]*(I_SGs[4, 1]*status_SGs[7]+ I_SGs[4, 2]*status_SGs[8])+
                Z[j,27]*(I_SGs[5, 1]*status_SGs[9]+ I_SGs[5, 2]*status_SGs[10])+
                Z[j,30]*(I_SGs[6, 1]*status_SGs[11]+ I_SGs[6, 2]*status_SGs[12])+
                Z[j,1]*I_IBG*status_IBG[1]+ Z[j,23]*I_IBG*status_IBG[2]+ Z[j,26]*I_IBG*status_IBG[3])/Z[j,j]   # calculate the SCC for SGs, buses:2,3,4,5,27,30
        
        end
    end
    
    return I_SCC_all_buses_scenarios, matrix_ω
    
    
end
